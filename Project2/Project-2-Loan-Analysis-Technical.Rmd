---
title: "LendingClub Peer-to-Peer Loan Analysis"
author: "Team 1: Jonathan Schild, Medhasweta Sen, Brian Gulko, Bharat Premnath"
date: "`r Sys.Date()`"
always_allow_html: true
output:
  html_document:
    code_folding: hide
    number_sections: yes
    toc: yes
    toc_depth: 3
    toc_float: yes
  pdf_document:
    toc: yes=
    toc_depth: '3'
  word_document:
    toc: no
    toc_depth: '3'
---

```{r setup, include=FALSE}
# We want the results to be hidden by default, though for some chunks we will override this to show the results
knitr::opts_chunk$set(warning = F, results = "hide", message = F)
```

```{r include=FALSE}
library(ezids) # We will use functions form this package to get nicer looking results
library(tidyverse) # We need this package for data manipulation, piping, and graphing
library(corrplot) # We will need this package to plot the correlation matrix
# library(scales) # This package will help us when labeling the scatter plots
# library(gridExtra) # For additional table and image functionality
# library(expss)
library(knitr)
library(kableExtra)
# library(broom)
# library(purrr)
library(rpart) # For the classification tree model
library(caret) # For the classification tree model
set.seed(1) # For the classification tree model
library(rpart.plot) # For plotting nice looking classification trees
library(pROC) # For ROC/AUC

# Read in the data from the working directory
loans <- read_csv("loan_data.csv")
#loans
```



# Introduction
We are using the same dataset from our first project. The dataset contains `r nrow(loans)` observations and `r ncol(loans)` variables and is based on loans from LendingClub, a peer-to-peer lending company, that were made from 2007 to 2015. In summary, our EDA found:

1. The credit underwriting criteria of LendingClub is proven to be effective as borrowers who do not meet the credit underwriting criteria are more than twice as likely to default in comparison to borrowers who do meet the criteria.  
2. There are some proven relationships between `credit.policy` and other numeric variables such as `int.rate`, `fico`, and `inq.last.6mths`. Additionally, there was no clearly established relationships between `not.fully.paid` and other numeric variables (except for `credit.policy`).  
3. There are statistically significant relationships between the categorical and logical variables `purpose`, `credit.policy`, and `not.fully.paid`.  
4. For all numeric variables except for `delinq.2yrs`, their mean significantly varies for different categories of`purpose`.

We obtained the dataset from Kaggle here: https://www.kaggle.com/datasets/urstrulyvikas/lending-club-loan-data-analysis

Our work is stored on our team GitHub here: https://github.com/jschild01/JMB_DATS_6101



# Preparing the Dataset for Modeling

## Converting Variables
From our EDA in project 1 we know that the `credit.policy` and `not.fully.paid` variables function as logicals, and the `purpose` variable functions as a factor with 7 levels. We will start by formally converting these variables from numerical date-types in R to logicals and the factor date-type, respectively.

```{r}
# We determined this makes sense to do from our EDA
str(loans) # keep??
loans$credit.policy <- as.logical(loans$credit.policy)
loans$not.fully.paid <- as.logical(loans$not.fully.paid)

loans$purpose <- as.factor(loans$purpose)
```

Of the `r ncol(loans)` variables in the dataset, 11 are numeric, 2 are logical, and 1 is a factor.


## Adding Additional Logicals
From our EDA we saw that the overwhelming majority of loans had a value of 0 for `delinq.2yrs` and `pub.rec`. The variables might be more useful in terms of having stronger correlations and a larger impact in models if we create logical versions of these variables. We will introduce `has.delinq.2yrs` and `has.pub.rec` based on whether or not the value is 0 or greater than 0.

```{r}
# It might help to turn these variables into logicals since most are 0
loans <- loans %>%
  mutate(has.delinq.2yrs = delinq.2yrs > 0,
         has.pub.rec = pub.rec > 0)
```


## Revolving Balance Transformation
From our EDA we saw that the `revol.bal` variable had a wide range of values as well as outlier issues. We wondered if it would work better if we took the natural log of it, similar to how the income provided in the dataset the dataset (the `log.annual.inc` variable) is in the form of the natural log. However, some values for `revol.bal` are 0, and taking the natural log of that results in -Inf. One way to deal with this without removing those values is to add 1 to all of the values for `revol.bal` before taking the natural log. 

Given the range of these values (the IQr is `r IQR(loans$revol.bal)`) adding one should have a negligible effect, and adding one to all values keeps the data consistent. In case it is significant that the `revol.bal` is 0 we will add a logical variable `has.revol.bal` based on whether the value of `revol.bal` is 0 or greater than 0.

```{r}
# Some loans have a revol.bal value of 0, the natural log of which is -Inf
# Adding 1 to all values before taking the natural log resolves this issue by nudging the value a very small amount
# In case it was meaningful if the loan had a revol.bal value of 0 versus >0, we can add a logical to account for that
loans <- loans %>%
  mutate(log.revol.bal = log(revol.bal+1),
         has.revol.bal = revol.bal > 0)
```


## Utility of the new variables
Now that we have added some new variables, it would be helpful to look at a correlation plot and make some comparisons to assess whether they would be more useful going forward than their original forms.

```{r fig.width=8, fig.height=8}
# A new correlation matrix with the new and transformed variables
# For our correlation matrix we want to include everything but the purpose variable
# We can put the new variables together at the top
loans_correlation_matrix_new <- loans %>%
  select(-purpose) %>%
  select(revol.bal, log.revol.bal, has.revol.bal, has.delinq.2yrs, has.pub.rec, everything()) %>%
  cor()

# The mixed correlation plot makes a nice visualization
corrplot.mixed(loans_correlation_matrix_new, tl.pos = "lt")
```

Some notable observations of this:
1. `has.delinq.2yrs` doesn't have any strong correlations, and the 2 potentially useful ones (`int.rate` and `fico`) are almost exactly the same as `delinq.2yrs`.
2. Similarly, `has.pub.rec` doesn't have any strong correlations, and the 2 potentially useful ones (`int.rate` and `fico`) are   the same as `pub.rec`.
3. `log.revol.bal` has a stronger correlation with `dti` and a much stronger correlation with `revol.util` compared to `revol.bal`.
4. `log.revol.bal` has a weaker correlation with `credit.policy` compared to `revol.bal`.
5. `has.revol.bal` does not have a significant correlation with anything (`log.revol.bal` excepted) except `revol.util`, where the correlation is significantly weaker than that of `log.revol.bal`.


From this we can conclude that converting `delinq.2yrs` and `pub.rec` to logicals did not add any advantage for our dataset. We can also conclude that the `has.revol.bal` variable is not necessary and will not add value to our analysis beyond what `log.revol.bal` already covers. Successfully eliminating these as possibilities increases our confidence in the use of their original structures.

Lastly, we see that taking the natural log of `revol.bal` might be useful, as `log.revol.bal` has some stronger correlations than `revol.bal`. We will note this as we proceed with our modeling. 



## Outlier Removal

### Removing the outliers

At this point, to improve the quality of our data, it would be helpful to remove outliers from our numeric variables, including the new `log.revol.bal` variable.

```{r}
# Using the outlierKD2 function from the ezids package on all numeric variables
loans_with_outliers <- loans
loans <- outlierKD2(loans, days.with.cr.line, rm = TRUE, qqplt = T)
loans <- outlierKD2(loans, delinq.2yrs, rm = TRUE, qqplt = T)
loans <- outlierKD2(loans, dti, rm = TRUE, qqplt = T)
loans <- outlierKD2(loans, fico, rm = TRUE, qqplt = T)
loans <- outlierKD2(loans, inq.last.6mths, rm = TRUE, qqplt = T)
loans <- outlierKD2(loans, installment, rm = TRUE, qqplt = T)
loans <- outlierKD2(loans, int.rate, rm = TRUE, qqplt = T)
loans <- outlierKD2(loans, log.annual.inc, rm = TRUE, qqplt = T)
loans <- outlierKD2(loans, pub.rec, rm = TRUE, qqplt = T)
loans <- outlierKD2(loans, revol.bal, rm = TRUE, qqplt = T)
loans <- outlierKD2(loans, revol.util, rm = TRUE, qqplt = T)
loans <- outlierKD2(loans, log.revol.bal, rm = TRUE, qqplt = T)
```


### Number of outliers removed

To help us understand the effect this had, let's put together a table to show how many outliers were removed from each variable.

```{r results="show"}
# Number of outliers for each variable
loans %>%
  is.na() %>%
  as.data.frame() %>%
  summarize_all(sum) %>%
  gather(variable, num_outliers_removed) %>%
  kable() %>%
  kable_styling(bootstrap_options = c("striped", "condensed"), full_width = FALSE)
```

We can see `delinq.2yrs` had the most outliers followed by `revol.bal`. Notably, `log.revol.bal` had fewer outliers than `revol.bal` (`r (sum(is.na(loans$log.revol.bal)))` vs `r (sum(is.na(loans$revol.bal)))`).

### Correlation plot without outliers

With the outliers removed, it is worth making another correlation plot to see how removing the outliers affects the correlations between variables.

```{r fig.width=8, fig.height=8, echo=FALSE}
# New correlation matrix with the outliers removed
# For our correlation matrix we want to include everything but the purpose variable
loans_correlation_matrix_new_minus_outliers <- loans %>%
  select(-purpose) %>%
  cor(use = "pairwise.complete.obs")

# The mixed correlation plot makes a nice visualization
corrplot.mixed(loans_correlation_matrix_new_minus_outliers, tl.pos = "lt")
```

For `delinq.2yrs` and `pub.rec`, such a large portion of the loans had the same value (zero) that anything else was considered an outlier and removed. As a result, these variables cannot have a correlation computed.

To add: Other observations about the impact of removing variables.

This version of our dataset with outliers removed will serve as our final dataset which we will use in our models for the rest of this project.

## Outlier Removal Graphs

Now that we have our final dataset, we can revisit our histograms, boxplots, and q-q plots to see how they look with the new variables and outliers removed compared to the dataset with outliers.


### Histograms
```{r fig.width=8, echo=FALSE}
# By gathering the variables we want to see into a long format with the gather() function, we can then create a histogram
# for each variable using the facet_wrap() function in ggplot2.
loans_with_outliers %>%
  select(int.rate, installment, log.annual.inc, dti, fico, days.with.cr.line, revol.bal, revol.util,
           inq.last.6mths, delinq.2yrs, pub.rec, log.revol.bal) %>%
  gather(variable, value) %>%
  ggplot(aes(x = value)) +
  geom_histogram(fill = "steelblue", color = "black") +
  facet_wrap(~ variable, scales = "free") + # Free scales so the graphs are readable
  labs(title = "Histograms of Numeric Variables", x = "Value", y = "Count") +
  theme_minimal()

# Outliers removed
loans %>%
  select(int.rate, installment, log.annual.inc, dti, fico, days.with.cr.line, revol.bal, revol.util,
           inq.last.6mths, delinq.2yrs, pub.rec, log.revol.bal) %>%
  gather(variable, value) %>%
  ggplot(aes(x = value)) +
  geom_histogram(fill = "steelblue", color = "black") +
  facet_wrap(~ variable, scales = "free") + # Free scales so the graphs are readable
  labs(title = "Histograms of Numeric Variables", x = "Value", y = "Count") +
  theme_minimal()
```


### Boxplots
```{r fig.width=8, echo=FALSE}
# By gathering the variables we want to see into a long format with the gather() function, we can then create a boxplot
# for each variable using the facet_wrap() function in ggplot2.
loans_with_outliers %>%
  select(int.rate, installment, log.annual.inc, dti, fico, days.with.cr.line, revol.bal, revol.util,
           inq.last.6mths, delinq.2yrs, pub.rec, log.revol.bal) %>%
  gather(variable, value) %>%
  ggplot(aes(x = value)) +
  geom_boxplot(fill = "steelblue", color = "black",
               outlier.size = 2, outlier.alpha = 0.2) + # Translucent and larger outliers to help with overplotting
  facet_wrap(~ variable, scales = "free") + # Free scales so the graphs are readable
  labs(title = "Boxplots of Numeric Variables", x = "Value") +
  theme_minimal() +
  theme(axis.text.y = element_blank(), axis.ticks.y = element_blank())

# Outliers removed
loans %>%
  select(int.rate, installment, log.annual.inc, dti, fico, days.with.cr.line, revol.bal, revol.util,
           inq.last.6mths, delinq.2yrs, pub.rec, log.revol.bal) %>%
  gather(variable, value) %>%
  ggplot(aes(x = value)) +
  geom_boxplot(fill = "steelblue", color = "black",
               outlier.size = 2, outlier.alpha = 0.2) + # Translucent and larger outliers to help with overplotting
  facet_wrap(~ variable, scales = "free") + # Free scales so the graphs are readable
  labs(title = "Boxplots of Numeric Variables", x = "Value") +
  theme_minimal() +
  theme(axis.text.y = element_blank(), axis.ticks.y = element_blank())
```


### Q-Q Plots
```{r echo=FALSE}
# By gathering the variables we want to see into a long format with the gather() function, we can then create a Q-Q plot
# for each variable using the facet_wrap() function in ggplot2.
loans_with_outliers %>%
  select(int.rate, installment, log.annual.inc, dti, fico, days.with.cr.line, revol.bal, revol.util,
           inq.last.6mths, delinq.2yrs, pub.rec, log.revol.bal) %>%
  gather(variable, value) %>%
  ggplot(aes(sample = value)) +
  geom_qq(color = "steelblue") +
  geom_qq_line() +
  facet_wrap(~ variable, scales = "free") + # Free scales so the graphs are readable
  labs(title = "Q-Q Plots of Numeric Variables", x = "Theoretical", y = "Sample") +
  theme_minimal()

# Outliers removed
loans %>%
  select(int.rate, installment, log.annual.inc, dti, fico, days.with.cr.line, revol.bal, revol.util,
           inq.last.6mths, delinq.2yrs, pub.rec, log.revol.bal) %>%
  gather(variable, value) %>%
  ggplot(aes(sample = value)) +
  geom_qq(color = "steelblue") +
  geom_qq_line() +
  facet_wrap(~ variable, scales = "free") + # Free scales so the graphs are readable
  labs(title = "Q-Q Plots of Numeric Variables", x = "Theoretical", y = "Sample") +
  theme_minimal()
```


To add: observations about the differences.



# Classification Tree

## Preparing and Building the Tree
Since one of our variables of intrest, `credit.policy` is a logical, we can treat is as a 2-level factor and build a classification tree model using the variables it has significant correlation with, in this case `int.rate`, `fico`, and `inq.last.6mths`.

For this variable we are interested in the loans where the value is `FALSE`. That is, loans that do not meet the credit underwriting criteria, and therefore are more at risk of defaulting. These loans are in the minority. We will rename the `FALSE` values to `Fail`, indicating that the loan fails to meet the underwriting criteria, and rename the `TRUE` values to `Meets`, indicating that the loan meets the underwriting criteria. 

Building the classification tree, we can see that `int.rate` was not used in the model, but `fico`, and `inq.last.6mths` were.

```{r results="show", fig.dim=c(6,4)}
# Since we are renaming some values let's make a separate dataset for this model
# loans_tree <- loans
loans_tree <- loans_with_outliers

# First convert the credit.policy variable from a logical to a factor, then rename the levels
loans_tree$credit.policy <- as.factor(loans_tree$credit.policy) %>%
  fct_recode(Meets = "TRUE", Fails = "FALSE")

# Max depth of 4 based on Professor Faruqe's instructions
creditfit <- rpart(credit.policy ~ int.rate + fico + inq.last.6mths, data=loans_tree, method="class", control = list(maxdepth = 4) )
printcp(creditfit) # display the results 
plotcp(creditfit) # visualize cross-validation results
```



```{r}
# Show these results??
summary(creditfit) # detailed summary of splits
```

To add: comments on results


## Visualizing the Tree

We can better visualize the tree by plotting it out. We can see the `inq.last.6mths` threshold of greater than or equal to four, as well as the two thresholds of 740 and 660 or `FICO` scores. It details that of our 9578 loan sample, there are 1868 loans that failed to meet the `credit.policy` and 7710 that did. 


```{r}
# plot the tree and add text
rpart.plot(creditfit, uniform=TRUE, main="Classification Tree for Credit.Policy", digits = 3, extra = 1)
#plot(creditfit, uniform=TRUE, main="Classification Tree for credit.policy")
#text(creditfit, use.n=TRUE, all=TRUE, cex=.75)

```
Of all of the loans, 1231 had more greater than or equal to four `inq.last.6mths`. Of those 1231:

* 1047 had a `FICO` lower than 740 and failed to meet the `credit.policy`
* 21 had a `FICO` score 740 or higher and failed to meet the `credit.policy`
* 163 had a `FICO` score 740 or higher and met the `credit.policy`

This indicates that applicants will likely need a `FICO` score of 740 or higher if they have greater than or equal to four `inq.last.6mths` in order to anticipate meeting the `credit.policy`.


Conversely, of all of the loans, 8347 had less than four `inq.last.6mths`. Of those 8347:

* 352 had a `FICO` lower than 660 and failed to meet the `credit.policy`
* 2 had a `FICO` lower than 660 but still managed to meet the `credit.policy`
* 448 had a `FICO` score 660 or higher and failed to meet the `credit.policy`
* 7545 had a `FICO` score 660 or higher and met the `credit.policy`

This indicates that applicants will likely need a `FICO` score of only 660 or higher if they have less than four `inq.last.6mths` in order to anticipate meeting the `credit.policy`.

Overall, we can see that less `inq.last.6mths` aligns with lower `FICO` score requirements for the `credit.policy`. Generally, if applicants have equal to or more than four `inq.last.6mths`, then they will likely need a `FICO` score of 740 or higher to meet the `credit.policy`. On the other hand, if applicants have less than four `inq.last.6mths`, then they will likely only need a `FICO` score of 660 or higher to meet the `credit.policy`. If applicants have a `FICO` score lower than 660, then they are unlikely to meet the `credit.policy`, regardless.


```{r}
# create a postscript plot of tree 
# The rpart.plot() function looks quite nice, so we may not need this
post(creditfit, file = "credittree2.ps", title = "Classification Tree for credit.policy")
```


## Confusion Matrix

To better understand how our model performs we can construct a confusion matrix of the results. The `Fails` values will function as the positive cases for the confusion matrix we put together based on the results of the classification tree model.
```{r results="show"}
# Creating the confusion matrix
confusion_matrix = confusionMatrix(predict(creditfit, type = "class"), reference = loans_tree$credit.policy)
print('Overall: ')
confusion_matrix$overall
print('Class: ')
confusion_matrix$byClass
#The Kappa statistic (or value) is a metric that compares an Observed Accuracy with an Expected Accuracy (random chance). The kappa statistic is used not only to evaluate a single classifier, but also to evaluate classifiers amongst themselves.According to their scheme a value < 0 is indicating no agreement , 0–0.20 as slight, 0.21–0.40 as fair, 0.41–0.60 as moderate, 0.61–0.80 as substantial, and 0.81–1 as almost perfect agreement. 
```
Based on the Kappa statistic of `r round(confusion_matrix$overall["Kappa"], digits=2)` we would evaluate this classifier as almost perfect agreement.

To add: other comments on the overall stats of the model.

From the Trees.rmd file:
The overall accuracy is `r round(confusion_matrix$overall["Accuracy"]*100, digits=2)`%. These are the same metrics of sensitivity (also known as recall rate, TP / (TP+FN) ), specificity (TN / (TN+FP) ), F1 score, and others that we used in Logistic Regression and KNN analyses. Indeed, any "classifiers" can use the confusion matrix approach as one of the evaluation tools. 


Let's put together tables to visualize the confusion matrix as well some statistics on it.

```{r results="show"}
# Creating the confusion matrix table
# To get a table that follows the same format as our notes, with the rows representing true values and columns representing predicted values, we will have to adjust the data a bit.

# Start by converting to a data.frame
cm_table <- as.data.frame(confusion_matrix$table) %>%
  rename(Actual = "Reference")

# Make it so that the rows represent true values and columns represent predicted values
cm_table$Prediction <- paste0("Prediction - ", cm_table$Prediction)
cm_table <- spread(cm_table, Prediction, Freq)

# Output a nice table
# xkabledply(cm_table, title = "Confusion matrix for the tree model")
cm_table %>%
  kable() %>%
  kable_styling(bootstrap_options = c("striped", "condensed"), full_width = FALSE)

## Can we bold the values in the first column ("Actual") using kable??
```

```{r results="show"}
#Creating a table for the confusion matrix statistics
# Start by converting to a data.frame
cm_stats <- as.data.frame(confusion_matrix$byClass) %>%
  rownames_to_column()

# Adjust the column names and values to look better
colnames(cm_stats) <- c("Statistic", "Percentage")
cm_stats$Percentage <- paste0(round(cm_stats$Percentage*100, digits=1), "%")

# Output a nice table
# xkabledply(cm_stats, title = "Confusion matrix statistics for the tree model")
cm_stats %>%
  kable() %>%
  kable_styling(bootstrap_options = c("striped", "condensed"), full_width = FALSE)
```

For certain statistics this model performs extremely well, with  near 100% specificity, precision, and positive predictive value. Negative predictive value is also very high at around 94%. 

To add: further comments on the statistics of the model.



## ROC Curve

Can we do this for this type of model?

```{r}
library(pROC)

loans_tree$prediction <- predict(creditfit, type = "vector")
# loans_tree$prediction <- predict(creditfit, type = "prob")[,2]
tree_roc <- roc(credit.policy ~ prediction, data=loans_tree)
auc(tree_roc) # area-under-curve prefer 0.8 or higher.
plot(tree_roc)


```


The AUC of the ROC is `r auc(tree_roc)`, which is greater than the 0.8 threshold, so we would consider this to be a good indicator/model.







