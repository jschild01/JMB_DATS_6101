# The package "ezids" (EZ Intro to Data Science) includes a lot of the helper functions we developed for the course.
# Some of the frequently used functions are loadPkg(), xkabledply(), xkablesummary(), uzscale(), etc.
library(ezids)
# some of common options (and the defaults) are:
# include=T, eval=T, echo=T, results='hide'/'asis'/'markup',..., collapse=F, warning=T, message=T, error=T, cache=T, fig.width=6, fig.height=4, fig.dim=c(6,4) #inches, fig.align='left'/'center','right',
# knitr::opts_chunk$set(warning = F, results = "markup", message = F)
knitr::opts_chunk$set(warning = F, results = "hide", message = F)
options(scientific=T, digits = 3)
# options(scipen=9, digits = 3)
# ‘scipen’: integer. A penalty to be applied when deciding to print numeric values in fixed or exponential notation.  Positive values bias towards fixed and negative towards scientific notation: fixed notation will be preferred unless it is more than ‘scipen’ digits wider.
# use scipen=999 to prevent scientific notation at all times
loadPkg("ggplot2")
# not.fully.paid <- data.frame(read.csv("LogRegnot.fully.paid.csv"))
df <- read.csv("loansnew.csv")
head(df)
summary(df)
str(df)
xkablesummary(df)
# find  sd for all columns, using sapply
varSD = sapply(df, sd)
varSD
xkabledply(as.table(varSD), title = "The sd for each variable in not.fully.paid", wide = TRUE)
not.fully.paidpurposetable = xtabs(~ not.fully.paid + purpose, data = df)
not.fully.paidpurposetable
df$not.fully.paid <- factor(df$not.fully.paid)
str(df)
df$purpose <- factor(df$purpose)
#str(not.fully.paid)
not.fully.paidLogit <- glm(not.fully.paid ~credit.policy+purpose+int.rate+installment+log.annual.inc+log.revol.bal, data = df, binomial(link = "logit") )
summary(not.fully.paidLogit)
xkabledply(not.fully.paidLogit, title = "Logistic Regression :")
p_fitted = not.fully.paidLogit$fitted.values[1] # this is the model predicated value p-hat for the first data row (not the actual data point p)
# This gives you the predicted values of the data points inside the model.
predict(not.fully.paidLogit)  # the is from the model, which gives you the value for logit(p) or ln(p/q)
## CIs using profiled log-likelihood
# confint(not.fully.paidLogit)
xkabledply( confint(not.fully.paidLogit), title = "CIs using profiled log-likelihood" )
## CIs using standard errors
# confint.default(not.fully.paidLogit)
xkabledply( confint.default(not.fully.paidLogit), title = "CIs using standard errors" )
loadPkg("regclass")
# confusion_matrix(not.fully.paidLogit)
xkabledply( confusion_matrix(not.fully.paidLogit), title = "Confusion matrix from Logit Model" )
unloadPkg("regclass")
loadPkg("pROC") # receiver operating characteristic curve, gives the diagnostic ability of a binary classifier system as its discrimination threshold is varied. The curve is on sensitivity/recall/true-positive-rate vs false_alarm/false-positive-rate/fall-out.
prob=predict(not.fully.paidLogit, type = "response" )
df$prob <- NA
df$prob=prob
not.fully.paidNullLogit <- glm(not.fully.paid ~ 1, data = df, family = "binomial")
mcFadden = 1 - logLik(not.fully.paidLogit)/logLik(not.fully.paidNullLogit)
mcFadden
loadPkg("pscl") # use pR2( ) function to calculate McFadden statistics for model eval
not.fully.paidLogitpr2 = pR2(not.fully.paidLogit)
not.fully.paidLogitpr2
unloadPkg("pscl")
loadPkg("ResourceSelection") # function hoslem.test( ) for logit model evaluation
notfullypaidLogitHoslem = hoslem.test(df$not.fully.paid, fitted(not.fully.paidLogit),g=10) # Hosmer and Lemeshow test, a chi-squared test
not.fully.paidLogitHoslem
# not.fully.paid <- data.frame(read.csv("LogRegnot.fully.paid.csv"))
df <- read.csv("loansnew.csv")
head(df)
summary(df)
str(df)
df.isna()
# not.fully.paid <- data.frame(read.csv("LogRegnot.fully.paid.csv"))
df <- read.csv("loansnew.csv")
head(df)
summary(df)
str(df)
isna(df)
# not.fully.paid <- data.frame(read.csv("LogRegnot.fully.paid.csv"))
df <- read.csv("loansnew.csv")
head(df)
summary(df)
str(df)
is.na(df)
# not.fully.paid <- data.frame(read.csv("LogRegnot.fully.paid.csv"))
df <- read.csv("loansnew.csv")
head(df)
summary(df)
str(df)
is.na(df).sum()
# not.fully.paid <- data.frame(read.csv("LogRegnot.fully.paid.csv"))
df <- read.csv("loansnew.csv")
head(df)
summary(df)
str(df)
sum(is.na(df))
# The package "ezids" (EZ Intro to Data Science) includes a lot of the helper functions we developed for the course.
# Some of the frequently used functions are loadPkg(), xkabledply(), xkablesummary(), uzscale(), etc.
library(ezids)
# some of common options (and the defaults) are:
# include=T, eval=T, echo=T, results='hide'/'asis'/'markup',..., collapse=F, warning=T, message=T, error=T, cache=T, fig.width=6, fig.height=4, fig.dim=c(6,4) #inches, fig.align='left'/'center','right',
# knitr::opts_chunk$set(warning = F, results = "markup", message = F)
knitr::opts_chunk$set(warning = F, results = "hide", message = F)
options(scientific=T, digits = 3)
# options(scipen=9, digits = 3)
# ‘scipen’: integer. A penalty to be applied when deciding to print numeric values in fixed or exponential notation.  Positive values bias towards fixed and negative towards scientific notation: fixed notation will be preferred unless it is more than ‘scipen’ digits wider.
# use scipen=999 to prevent scientific notation at all times
loadPkg("ggplot2")
# not.fully.paid <- data.frame(read.csv("LogRegnot.fully.paid.csv"))
df <- read.csv("loan_data.csv")
head(df)
summary(df)
str(df)
sum(is.na(df))
xkablesummary(df)
# find  sd for all columns, using sapply
varSD = sapply(df, sd)
varSD
xkabledply(as.table(varSD), title = "The sd for each variable in not.fully.paid", wide = TRUE)
not.fully.paidpurposetable = xtabs(~ not.fully.paid + purpose, data = df)
not.fully.paidpurposetable
df$not.fully.paid <- factor(df$not.fully.paid)
str(df)
df$purpose <- factor(df$purpose)
#str(not.fully.paid)
not.fully.paidLogit <- glm(not.fully.paid ~credit.policy+purpose+int.rate+installment+log.annual.inc+revol.bal, data = df, binomial(link = "logit") )
summary(not.fully.paidLogit)
xkabledply(not.fully.paidLogit, title = "Logistic Regression :")
p_fitted = not.fully.paidLogit$fitted.values[1] # this is the model predicated value p-hat for the first data row (not the actual data point p)
# This gives you the predicted values of the data points inside the model.
predict(not.fully.paidLogit)  # the is from the model, which gives you the value for logit(p) or ln(p/q)
## CIs using profiled log-likelihood
# confint(not.fully.paidLogit)
xkabledply( confint(not.fully.paidLogit), title = "CIs using profiled log-likelihood" )
## CIs using standard errors
# confint.default(not.fully.paidLogit)
xkabledply( confint.default(not.fully.paidLogit), title = "CIs using standard errors" )
loadPkg("regclass")
# confusion_matrix(not.fully.paidLogit)
xkabledply( confusion_matrix(not.fully.paidLogit), title = "Confusion matrix from Logit Model" )
unloadPkg("regclass")
loadPkg("pROC") # receiver operating characteristic curve, gives the diagnostic ability of a binary classifier system as its discrimination threshold is varied. The curve is on sensitivity/recall/true-positive-rate vs false_alarm/false-positive-rate/fall-out.
prob=predict(not.fully.paidLogit, type = "response" )
df$prob <- NA
df$prob=prob
h <- roc(not.fully.paid~prob, data=df)
auc(h) # area-under-curve prefer 0.8 or higher.
plot(h)
# unloadPkg("pROC")
head(df)
not.fully.paidNullLogit <- glm(not.fully.paid ~ 1, data = df, family = "binomial")
mcFadden = 1 - logLik(not.fully.paidLogit)/logLik(not.fully.paidNullLogit)
mcFadden
loadPkg("pscl") # use pR2( ) function to calculate McFadden statistics for model eval
not.fully.paidLogitpr2 = pR2(not.fully.paidLogit)
not.fully.paidLogitpr2
unloadPkg("pscl")
loadPkg("ResourceSelection") # function hoslem.test( ) for logit model evaluation
notfullypaidLogitHoslem = hoslem.test(df$not.fully.paid, fitted(not.fully.paidLogit),g=10) # Hosmer and Lemeshow test, a chi-squared test
not.fully.paidLogitHoslem
notfullypaidLogitHoslem = hoslem.test(df$not.fully.paid, fitted(not.fully.paidLogit) # Hosmer and Lemeshow test, a chi-squared test
notfullypaidLogitHoslem = hoslem.test(df$not.fully.paid, fitted(not.fully.paidLogit)) # Hosmer and Lemeshow test, a chi-squared test
not.fully.paidLogitHoslem
loadPkg("ResourceSelection") # function hoslem.test( ) for logit model evaluation
loadPkg("ResourceSelection") # function hoslem.test( ) for logit model evaluation
notfullypaidLogitHoslem = hoslem.test(df$not.fully.paid, fitted(not.fully.paidLogit)) # Hosmer and Lemeshow test, a chi-squared test
not.fully.paidLogitHoslem
not.fullypaidLogitHoslem = hoslem.test(df$not.fully.paid, fitted(not.fully.paidLogit)) # Hosmer and Lemeshow test, a chi-squared test
not.fully.paidLogitHoslem
not.fully.paidLogitHoslem = hoslem.test(df$not.fully.paid, fitted(not.fully.paidLogit)) # Hosmer and Lemeshow test, a chi-squared test
not.fully.paidLogitHoslem
# Have not found a good way to display it.
# The package "ezids" (EZ Intro to Data Science) includes a lot of the helper functions we developed for the course.
# Some of the frequently used functions are loadPkg(), xkabledply(), xkablesummary(), uzscale(), etc.
library(ezids)
# some of common options (and the defaults) are:
# include=T, eval=T, echo=T, results='hide'/'asis'/'markup',..., collapse=F, warning=T, message=T, error=T, cache=T, fig.width=6, fig.height=4, fig.dim=c(6,4) #inches, fig.align='left'/'center','right',
# knitr::opts_chunk$set(warning = F, results = "markup", message = F)
knitr::opts_chunk$set(warning = F, results = "hide", message = F)
options(scientific=T, digits = 3)
# options(scipen=9, digits = 3)
# ‘scipen’: integer. A penalty to be applied when deciding to print numeric values in fixed or exponential notation.  Positive values bias towards fixed and negative towards scientific notation: fixed notation will be preferred unless it is more than ‘scipen’ digits wider.
# use scipen=999 to prevent scientific notation at all times
loadPkg("ggplot2")
# not.fully.paid <- data.frame(read.csv("LogRegnot.fully.paid.csv"))
df <- read.csv("loan_data.csv")
head(df)
summary(df)
str(df)
sum(is.na(df))
xkablesummary(df)
# find  sd for all columns, using sapply
varSD = sapply(df, sd)
varSD
xkabledply(as.table(varSD), title = "The sd for each variable in not.fully.paid", wide = TRUE)
not.fully.paidpurposetable = xtabs(~ not.fully.paid + purpose, data = df)
not.fully.paidpurposetable
df$not.fully.paid <- factor(df$not.fully.paid)
str(df)
df$purpose <- factor(df$purpose)
#str(not.fully.paid)
not.fully.paidLogit <- glm(not.fully.paid ~credit.policy+purpose+int.rate+installment+log.annual.inc+revol.bal, data = df, binomial(link = "logit") )
summary(not.fully.paidLogit)
xkabledply(not.fully.paidLogit, title = "Logistic Regression :")
p_fitted = not.fully.paidLogit$fitted.values[1] # this is the model predicated value p-hat for the first data row (not the actual data point p)
# This gives you the predicted values of the data points inside the model.
predict(not.fully.paidLogit)  # the is from the model, which gives you the value for logit(p) or ln(p/q)
## CIs using profiled log-likelihood
# confint(not.fully.paidLogit)
xkabledply( confint(not.fully.paidLogit), title = "CIs using profiled log-likelihood" )
## CIs using standard errors
# confint.default(not.fully.paidLogit)
xkabledply( confint.default(not.fully.paidLogit), title = "CIs using standard errors" )
loadPkg("regclass")
# confusion_matrix(not.fully.paidLogit)
xkabledply( confusion_matrix(not.fully.paidLogit), title = "Confusion matrix from Logit Model" )
unloadPkg("regclass")
loadPkg("pROC") # receiver operating characteristic curve, gives the diagnostic ability of a binary classifier system as its discrimination threshold is varied. The curve is on sensitivity/recall/true-positive-rate vs false_alarm/false-positive-rate/fall-out.
prob=predict(not.fully.paidLogit, type = "response" )
df$prob <- NA
df$prob=prob
h <- roc(not.fully.paid~prob, data=df)
auc(h) # area-under-curve prefer 0.8 or higher.
plot(h)
# unloadPkg("pROC")
head(df)
not.fully.paidNullLogit <- glm(not.fully.paid ~ 1, data = df, family = "binomial")
mcFadden = 1 - logLik(not.fully.paidLogit)/logLik(not.fully.paidNullLogit)
mcFadden
loadPkg("pscl") # use pR2( ) function to calculate McFadden statistics for model eval
not.fully.paidLogitpr2 = pR2(not.fully.paidLogit)
not.fully.paidLogitpr2
unloadPkg("pscl")
loadPkg("ResourceSelection") # function hoslem.test( ) for logit model evaluation
not.fully.paidLogitHoslem = hoslem.test(df$not.fully.paid, fitted(not.fully.paidLogit)) # Hosmer and Lemeshow test, a chi-squared test
not.fully.paidLogitHoslem
# Have not found a good way to display it.
# credit.policy <- data.frame(read.csv("LogRegcredit.policy.csv"))
df <- read.csv("loan_data.csv")
head(df)
summary(df)
str(df)
sum(is.na(df))
xkablesummary(df)
# The package "ezids" (EZ Intro to Data Science) includes a lot of the helper functions we developed for the course.
# Some of the frequently used functions are loadPkg(), xkabledply(), xkablesummary(), uzscale(), etc.
library(ezids)
# some of common options (and the defaults) are:
# include=T, eval=T, echo=T, results='hide'/'asis'/'markup',..., collapse=F, warning=T, message=T, error=T, cache=T, fig.width=6, fig.height=4, fig.dim=c(6,4) #inches, fig.align='left'/'center','right',
# knitr::opts_chunk$set(warning = F, results = "markup", message = F)
knitr::opts_chunk$set(warning = F, results = "hide", message = F)
options(scientific=T, digits = 3)
# options(scipen=9, digits = 3)
# ‘scipen’: integer. A penalty to be applied when deciding to print numeric values in fixed or exponential notation.  Positive values bias towards fixed and negative towards scientific notation: fixed notation will be preferred unless it is more than ‘scipen’ digits wider.
# use scipen=999 to prevent scientific notation at all times
xkablesummary(df)
# find  sd for all columns, using sapply
varSD = sapply(df, sd)
varSD
xkabledply(as.table(varSD), title = "The sd for each variable in credit.policy", wide = TRUE)
credit.policypurposetable = xtabs(~ credit.policy + purpose, data = df)
credit.policypurposetable
# The package "ezids" (EZ Intro to Data Science) includes a lot of the helper functions we developed for the course.
# Some of the frequently used functions are loadPkg(), xkabledply(), xkablesummary(), uzscale(), etc.
library(ezids)
# some of common options (and the defaults) are:
# include=T, eval=T, echo=T, results='hide'/'asis'/'markup',..., collapse=F, warning=T, message=T, error=T, cache=T, fig.width=6, fig.height=4, fig.dim=c(6,4) #inches, fig.align='left'/'center','right',
# knitr::opts_chunk$set(warning = F, results = "markup", message = F)
knitr::opts_chunk$set(warning = F, results = "hide", message = F)
options(scientific=T, digits = 3)
# options(scipen=9, digits = 3)
# ‘scipen’: integer. A penalty to be applied when deciding to print numeric values in fixed or exponential notation.  Positive values bias towards fixed and negative towards scientific notation: fixed notation will be preferred unless it is more than ‘scipen’ digits wider.
# use scipen=999 to prevent scientific notation at all times
loadPkg("ggplot2")
# credit.policy <- data.frame(read.csv("LogRegcredit.policy.csv"))
df <- read.csv("loan_data.csv")
head(df)
summary(df)
str(df)
sum(is.na(df))
xkablesummary(df)
# find  sd for all columns, using sapply
varSD = sapply(df, sd)
varSD
xkabledply(as.table(varSD), title = "The sd for each variable in credit.policy", wide = TRUE)
credit.policypurposetable = xtabs(~ credit.policy + purpose, data = df)
credit.policypurposetable
df$credit.policy <- factor(df$credit.policy)
str(df)
df$purpose <- factor(df$purpose)
#str(credit.policy)
credit.policyLogit <- glm(credit.policy ~purpose+log.annual.inc+revol.bal+fico+revol.util+pub.rec+inq.last.6mths , data = df, binomial(link = "logit") )
summary(credit.policyLogit)
xkabledply(credit.policyLogit, title = "Logistic Regression :")
p_fitted = credit.policyLogit$fitted.values[1] # this is the model predicated value p-hat for the first data row (not the actual data point p)
# This gives you the predicted values of the data points inside the model.
predict(credit.policyLogit)  # the is from the model, which gives you the value for logit(p) or ln(p/q)
## CIs using profiled log-likelihood
# confint(credit.policyLogit)
xkabledply( confint(credit.policyLogit), title = "CIs using profiled log-likelihood" )
## CIs using standard errors
# confint.default(credit.policyLogit)
xkabledply( confint.default(credit.policyLogit), title = "CIs using standard errors" )
loadPkg("regclass")
# confusion_matrix(credit.policyLogit)
xkabledply( confusion_matrix(credit.policyLogit), title = "Confusion matrix from Logit Model" )
unloadPkg("regclass")
loadPkg("pROC") # receiver operating characteristic curve, gives the diagnostic ability of a binary classifier system as its discrimination threshold is varied. The curve is on sensitivity/recall/true-positive-rate vs false_alarm/false-positive-rate/fall-out.
prob=predict(credit.policyLogit, type = "response" )
df$prob <- NA
df$prob=prob
h <- roc(credit.policy~prob, data=df)
auc(h) # area-under-curve prefer 0.8 or higher.
plot(h)
# unloadPkg("pROC")
head(df)
credit.policyNullLogit <- glm(credit.policy ~ 1, data = df, family = "binomial")
mcFadden = 1 - logLik(credit.policyLogit)/logLik(credit.policyNullLogit)
mcFadden
loadPkg("pscl") # use pR2( ) function to calculate McFadden statistics for model eval
credit.policyLogitpr2 = pR2(credit.policyLogit)
credit.policyLogitpr2
unloadPkg("pscl")
loadPkg("ResourceSelection") # function hoslem.test( ) for logit model evaluation
credit.policyLogitHoslem = hoslem.test(df$credit.policy, fitted(credit.policyLogit)) # Hosmer and Lemeshow test, a chi-squared test
credit.policyLogitHoslem
# Have not found a good way to display it.
